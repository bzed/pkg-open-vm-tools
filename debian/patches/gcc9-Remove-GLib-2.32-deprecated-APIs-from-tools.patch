From a7c141fc5278146b86c71502f60767962b752af7 Mon Sep 17 00:00:00 2001
From: Oliver Kurth <okurth@vmware.com>
Date: Tue, 18 Dec 2018 13:19:46 -0800
Subject: [PATCH] Remove GLib 2.32 deprecated APIs from tools

Replace the GThread, GCond and GMutex APIs deprecated in GLib version
2.32 in the VMware Tools source.

Backport Notes:
- open-vm-tools/lib/rpcChannel/rpcChannel.c context changes, still search/replace
- open-vm-tools/services/plugins/vmbackup/stateMachine.c.rej context changes, still search/replace
- open-vm-tools/services/vmtoolsd/toolsHangDetector.c - didn't exist in 10.3.10
- open-vm-tools/lib/rpcChannel/glib_stubs.c - didn't exist in 10.3.10

Origin: backport, https://github.com/vmware/open-vm-tools/commit/a7c141fc
Bug-Ubuntu: https://bugs.launchpad.net/bugs/1842301
Last-Update: 2019-09-03

---
 open-vm-tools/configure.ac                    |  2 +-
 open-vm-tools/lib/glibUtils/fileLogger.c      | 10 ++--
 open-vm-tools/lib/glibUtils/stdLogger.c       | 12 ++---
 open-vm-tools/lib/glibUtils/sysLogger.c       | 12 ++---
 .../lib/include/vmware/tools/threadPool.h     |  7 ++-
 open-vm-tools/lib/rpcChannel/glib_stubs.c     |  6 +--
 open-vm-tools/lib/rpcChannel/rpcChannel.c     | 20 +++----
 open-vm-tools/lib/rpcChannel/rpcChannelInt.h  |  2 +-
 open-vm-tools/libvmtools/i18n.c               | 16 +++---
 open-vm-tools/libvmtools/vmtoolsConfig.c      |  6 +--
 .../services/plugins/vmbackup/stateMachine.c  | 16 +++---
 .../services/plugins/vmbackup/vmBackupInt.h   |  6 +--
 open-vm-tools/services/vmtoolsd/cmdLine.c     |  2 -
 open-vm-tools/services/vmtoolsd/mainLoop.c    |  4 --
 open-vm-tools/services/vmtoolsd/serviceObj.c  | 16 +++---
 open-vm-tools/services/vmtoolsd/serviceObj.h  |  4 +-
 open-vm-tools/services/vmtoolsd/threadPool.c  | 52 +++++++++----------
 .../services/vmtoolsd/toolsHangDetector.c     |  1 +
 open-vm-tools/vgauth/service/fileLogger.c     |  4 --
 19 files changed, 93 insertions(+), 105 deletions(-)

--- a/open-vm-tools/configure.ac
+++ b/open-vm-tools/configure.ac
@@ -420,7 +420,7 @@ AC_ARG_ENABLE([grabbitmqproxy],
    ])
 
 #
-# Check for glib 2.6.14 or greater.
+# Check for glib 2.34.0 or greater.
 #
 AC_VMW_CHECK_LIB([glib-2.0],
                  [GLIB2],
--- a/open-vm-tools/lib/glibUtils/fileLogger.c
+++ b/open-vm-tools/lib/glibUtils/fileLogger.c
@@ -44,7 +44,7 @@ typedef struct FileLogger {
    guint          maxFiles;
    gboolean       append;
    gboolean       error;
-   GStaticMutex   lock;
+   GMutex         lock;
 } FileLogger;
 
 
@@ -348,7 +348,7 @@ FileLoggerLog(const gchar *domain,
    FileLogger *logger = data;
    gsize written;
 
-   g_static_mutex_lock(&logger->lock);
+   g_mutex_lock(&logger->lock);
 
    if (logger->error) {
       goto exit;
@@ -387,7 +387,7 @@ FileLoggerLog(const gchar *domain,
    }
 
 exit:
-   g_static_mutex_unlock(&logger->lock);
+   g_mutex_unlock(&logger->lock);
 }
 
 
@@ -409,7 +409,7 @@ FileLoggerDestroy(gpointer data)
    if (logger->file != NULL) {
       g_io_channel_unref(logger->file);
    }
-   g_static_mutex_free(&logger->lock);
+   g_mutex_clear(&logger->lock);
    g_free(logger->path);
    g_free(logger);
 }
@@ -456,7 +456,7 @@ GlibUtils_CreateFileLogger(const char *p
    data->append = append;
    data->maxSize = maxSize * 1024 * 1024;
    data->maxFiles = maxFiles + 1; /* To account for the active log file. */
-   g_static_mutex_init(&data->lock);
+   g_mutex_init(&data->lock);
 
    return &data->handler;
 }
--- a/open-vm-tools/lib/glibUtils/stdLogger.c
+++ b/open-vm-tools/lib/glibUtils/stdLogger.c
@@ -1,5 +1,5 @@
 /*********************************************************
- * Copyright (C) 2010-2016 VMware, Inc. All rights reserved.
+ * Copyright (C) 2010-2018 VMware, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as published
@@ -27,7 +27,7 @@
 #include <stdio.h>
 
 #if defined(_WIN32)
-static GStaticMutex gConsoleLock = G_STATIC_MUTEX_INIT;
+static GMutex gConsoleLock;
 static gint gRefCount = 0;
 #endif
 
@@ -66,12 +66,12 @@ StdLoggerLog(const gchar *domain,
    StdLogger *sdata = data;
 
    if (!sdata->attached) {
-      g_static_mutex_lock(&gConsoleLock);
+      g_mutex_lock(&gConsoleLock);
       if (gRefCount != 0 || GlibUtils_AttachConsole()) {
          gRefCount++;
          sdata->attached = TRUE;
       }
-      g_static_mutex_unlock(&gConsoleLock);
+      g_mutex_unlock(&gConsoleLock);
    }
 
    if (!sdata->attached) {
@@ -105,11 +105,11 @@ StdLoggerDestroy(gpointer data)
 {
 #if defined(_WIN32)
    StdLogger *sdata = data;
-   g_static_mutex_lock(&gConsoleLock);
+   g_mutex_lock(&gConsoleLock);
    if (sdata->attached && --gRefCount == 0) {
       FreeConsole();
    }
-   g_static_mutex_unlock(&gConsoleLock);
+   g_mutex_unlock(&gConsoleLock);
 #endif
    g_free(data);
 }
--- a/open-vm-tools/lib/glibUtils/sysLogger.c
+++ b/open-vm-tools/lib/glibUtils/sysLogger.c
@@ -1,5 +1,5 @@
 /*********************************************************
- * Copyright (C) 2010-2016 VMware, Inc. All rights reserved.
+ * Copyright (C) 2010-2018 VMware, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as published
@@ -38,7 +38,7 @@ typedef struct SysLogger {
 
 
 static SysLogger *gSysLogger;
-static GStaticMutex gSysLoggerLock = G_STATIC_MUTEX_INIT;
+static GMutex gSysLoggerLock;
 
 
 /*
@@ -105,7 +105,7 @@ SysLoggerUnref(gpointer data)
 {
    g_return_if_fail(data == gSysLogger);
    g_return_if_fail(gSysLogger->refcount > 0);
-   g_static_mutex_lock(&gSysLoggerLock);
+   g_mutex_lock(&gSysLoggerLock);
    gSysLogger->refcount -= 1;
    if (gSysLogger->refcount == 0) {
       closelog();
@@ -113,7 +113,7 @@ SysLoggerUnref(gpointer data)
       g_free(gSysLogger);
       gSysLogger = NULL;
    }
-   g_static_mutex_unlock(&gSysLoggerLock);
+   g_mutex_unlock(&gSysLoggerLock);
 }
 
 
@@ -140,7 +140,7 @@ GlibLogger *
 GlibUtils_CreateSysLogger(const char *domain,
                           const char *facility)
 {
-   g_static_mutex_lock(&gSysLoggerLock);
+   g_mutex_lock(&gSysLoggerLock);
    if (gSysLogger == NULL) {
       int facid = LOG_USER;
 
@@ -203,7 +203,7 @@ GlibUtils_CreateSysLogger(const char *do
    } else {
       gSysLogger->refcount += 1;
    }
-   g_static_mutex_unlock(&gSysLoggerLock);
+   g_mutex_unlock(&gSysLoggerLock);
    return &gSysLogger->handler;
 }
 
--- a/open-vm-tools/lib/include/vmware/tools/threadPool.h
+++ b/open-vm-tools/lib/include/vmware/tools/threadPool.h
@@ -1,5 +1,5 @@
 /*********************************************************
- * Copyright (C) 2010-2016 VMware, Inc. All rights reserved.
+ * Copyright (C) 2010-2018 VMware, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as published
@@ -70,6 +70,7 @@ typedef struct ToolsCorePool {
                    GDestroyNotify dtor);
    void (*cancel)(guint id);
    gboolean (*start)(ToolsAppCtx *ctx,
+                     const gchar *threadName,
                      ToolsCorePoolCb cb,
                      ToolsCorePoolCb interrupt,
                      gpointer data,
@@ -179,6 +180,7 @@ ToolsCorePool_CancelTask(ToolsAppCtx *ct
  * some other method of communicating with the thread.
  *
  * @param[in] ctx          Application context.
+ * @param[in] threadName   Name for the new thread.
  * @param[in] cb           Function that implements the task to execute.
  * @param[in] interrupt    A function that will request the task to be
  *                         interrupted. This will be called when the pool
@@ -197,6 +199,7 @@ ToolsCorePool_CancelTask(ToolsAppCtx *ct
 
 G_INLINE_FUNC gboolean
 ToolsCorePool_StartThread(ToolsAppCtx *ctx,
+                          const gchar *threadName,
                           ToolsCorePoolCb cb,
                           ToolsCorePoolCb interrupt,
                           gpointer data,
@@ -204,7 +207,7 @@ ToolsCorePool_StartThread(ToolsAppCtx *c
 {
    ToolsCorePool *pool = ToolsCorePool_GetPool(ctx);
    if (pool != NULL) {
-      return pool->start(ctx, cb, interrupt, data, dtor);
+      return pool->start(ctx, threadName, cb, interrupt, data, dtor);
    }
    return FALSE;
 }
--- a/open-vm-tools/lib/rpcChannel/rpcChannel.c
+++ b/open-vm-tools/lib/rpcChannel/rpcChannel.c
@@ -119,7 +119,7 @@ RpcChannelRestart(gpointer _chan)
    gboolean chanStarted;
 
    /* Synchronize with any RpcChannel_Send calls by other threads. */
-   g_static_mutex_lock(&chan->impl.outLock);
+   g_mutex_lock(&chan->impl.outLock);
 
    RpcChannelStopNoLock(&chan->impl);
 
@@ -128,7 +128,7 @@ RpcChannelRestart(gpointer _chan)
    gVSocketFailed = FALSE;
 
    chanStarted = RpcChannel_Start(&chan->impl);
-   g_static_mutex_unlock(&chan->impl.outLock);
+   g_mutex_unlock(&chan->impl.outLock);
    if (!chanStarted) {
       Warning("Channel restart failed [%d]\n", chan->rpcResetErrorCount);
       if (chan->resetCb != NULL) {
@@ -750,7 +750,7 @@ RpcChannel_New(void)
    chan = BackdoorChannel_New();
 #endif
    if (chan) {
-      g_static_mutex_init(&chan->outLock);
+      g_mutex_init(&chan->outLock);
    }
    return chan;
 }
@@ -766,7 +766,7 @@ void
 RpcChannel_Shutdown(RpcChannel *chan)
 {
    if (chan != NULL) {
-      g_static_mutex_free(&chan->outLock);
+      g_mutex_free(&chan->outLock);
    }
 
    if (chan != NULL && chan->funcs != NULL && chan->funcs->shutdown != NULL) {
@@ -883,9 +883,9 @@ RpcChannelStopNoLock(RpcChannel *chan)
 void
 RpcChannel_Stop(RpcChannel *chan)
 {
-   g_static_mutex_lock(&chan->outLock);
+   g_mutex_lock(&chan->outLock);
    RpcChannelStopNoLock(chan);
-   g_static_mutex_unlock(&chan->outLock);
+   g_mutex_unlock(&chan->outLock);
 }
 
 
@@ -952,7 +952,7 @@ RpcChannel_Send(RpcChannel *chan,
 
    ASSERT(chan && chan->funcs);
 
-   g_static_mutex_lock(&chan->outLock);
+   g_mutex_lock(&chan->outLock);
 
    funcs = chan->funcs;
    ASSERT(funcs->send);
@@ -1003,7 +1003,7 @@ done:
    }
 
 exit:
-   g_static_mutex_unlock(&chan->outLock);
+   g_mutex_unlock(&chan->outLock);
    return ok && rpcStatus;
 }
 
--- a/open-vm-tools/lib/rpcChannel/rpcChannelInt.h
+++ b/open-vm-tools/lib/rpcChannel/rpcChannelInt.h
@@ -69,7 +69,7 @@ struct _RpcChannel {
    const char                *appName;
    gpointer                  appCtx;
 #endif
-   GStaticMutex              outLock;
+   GMutex                    outLock;
 #if defined(NEED_RPCIN)
    struct RpcIn              *in;
    gboolean                  inStarted;
--- a/open-vm-tools/libvmtools/i18n.c
+++ b/open-vm-tools/libvmtools/i18n.c
@@ -1,5 +1,5 @@
 /*********************************************************
- * Copyright (C) 2010-2016 VMware, Inc. All rights reserved.
+ * Copyright (C) 2010-2018 VMware, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as published
@@ -54,7 +54,7 @@ typedef struct MsgCatalog {
 
 typedef struct MsgState {
    HashTable     *domains; /* List of text domains. */
-   GStaticMutex   lock;    /* Mutex to protect shared state. */
+   GMutex         lock;    /* Mutex to protect shared state. */
 } MsgState;
 
 
@@ -133,7 +133,7 @@ MsgInitState(gpointer unused)
 {
    ASSERT(gMsgState == NULL);
    gMsgState = g_new0(MsgState, 1);
-   g_static_mutex_init(&gMsgState->lock);
+   g_mutex_init(&gMsgState->lock);
    return NULL;
 }
 
@@ -344,7 +344,7 @@ MsgGetString(const char *domain,
     * This lock is pretty coarse-grained, but a lot of the code below just runs
     * in exceptional situations, so it should be OK.
     */
-   g_static_mutex_lock(&state->lock);
+   g_mutex_lock(&state->lock);
 
    catalog = MsgGetCatalog(domain);
    if (catalog != NULL) {
@@ -415,7 +415,7 @@ MsgGetString(const char *domain,
       }
    }
 
-   g_static_mutex_unlock(&state->lock);
+   g_mutex_unlock(&state->lock);
 
    return strp;
 }
@@ -682,7 +682,7 @@ VMToolsMsgCleanup(void)
       if (gMsgState->domains != NULL) {
          HashTable_Free(gMsgState->domains);
       }
-      g_static_mutex_free(&gMsgState->lock);
+      g_mutex_clear(&gMsgState->lock);
       g_free(gMsgState);
    }
 }
@@ -775,9 +775,9 @@ VMTools_BindTextDomain(const char *domai
                    "catalog dir '%s'.\n", domain, lang, catdir);
       }
    } else {
-      g_static_mutex_lock(&state->lock);
+      g_mutex_lock(&state->lock);
       MsgSetCatalog(domain, catalog);
-      g_static_mutex_unlock(&state->lock);
+      g_mutex_unlock(&state->lock);
    }
    g_free(file);
    free(dfltdir);
--- a/open-vm-tools/libvmtools/vmtoolsConfig.c
+++ b/open-vm-tools/libvmtools/vmtoolsConfig.c
@@ -1,5 +1,5 @@
 /*********************************************************
- * Copyright (C) 2008-2017 VMware, Inc. All rights reserved.
+ * Copyright (C) 2008-2018 VMware, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as published
@@ -330,11 +330,7 @@ VMTools_LoadConfig(const gchar *path,
    gchar *defaultPath = NULL;
    gchar *localPath = NULL;
    /* GStatBuf was added in 2.26. */
-#if GLIB_CHECK_VERSION(2, 26, 0)
    GStatBuf confStat;
-#else
-   struct stat confStat;
-#endif
    GHashTable *old = NULL;
    GError *err = NULL;
    GKeyFile *cfg = NULL;
--- a/open-vm-tools/services/plugins/vmbackup/stateMachine.c
+++ b/open-vm-tools/services/plugins/vmbackup/stateMachine.c
@@ -335,12 +335,12 @@ VmBackupFinalize(void)
       g_source_unref(gBackupState->abortTimer);
    }
 
-   g_static_mutex_lock(&gBackupState->opLock);
+   g_mutex_lock(&gBackupState->opLock);
    if (gBackupState->currentOp != NULL) {
       VmBackup_Cancel(gBackupState->currentOp);
       VmBackup_Release(gBackupState->currentOp);
    }
-   g_static_mutex_unlock(&gBackupState->opLock);
+   g_mutex_unlock(&gBackupState->opLock);
 
    VmBackup_SendEvent(VMBACKUP_EVENT_REQUESTOR_DONE, VMBACKUP_SUCCESS, "");
 
@@ -358,7 +358,7 @@ VmBackupFinalize(void)
    if (gBackupState->completer != NULL) {
       gBackupState->completer->release(gBackupState->completer);
    }
-   g_static_mutex_free(&gBackupState->opLock);
+   g_mutex_clear(&gBackupState->opLock);
    g_free(gBackupState->scriptArg);
    g_free(gBackupState->volumes);
    g_free(gBackupState->snapshots);
@@ -486,13 +486,13 @@ VmBackupDoAbort(void)
        gBackupState->machineState != VMBACKUP_MSTATE_SYNC_ERROR) {
       const char *eventMsg = "Quiesce aborted.";
       /* Mark the current operation as cancelled. */
-      g_static_mutex_lock(&gBackupState->opLock);
+      g_mutex_lock(&gBackupState->opLock);
       if (gBackupState->currentOp != NULL) {
          VmBackup_Cancel(gBackupState->currentOp);
          VmBackup_Release(gBackupState->currentOp);
          gBackupState->currentOp = NULL;
       }
-      g_static_mutex_unlock(&gBackupState->opLock);
+      g_mutex_unlock(&gBackupState->opLock);
 
 #ifdef __linux__
       /* If quiescing has been completed, then undo it.  */
@@ -559,7 +559,7 @@ VmBackupPostProcessCurrentOp(gboolean *p
 
    *pending = FALSE;
 
-   g_static_mutex_lock(&gBackupState->opLock);
+   g_mutex_lock(&gBackupState->opLock);
 
    if (gBackupState->currentOp != NULL) {
       g_debug("%s: checking %s\n", __FUNCTION__, gBackupState->currentOpName);
@@ -626,7 +626,7 @@ VmBackupPostProcessCurrentOp(gboolean *p
    }
 
 exit:
-   g_static_mutex_unlock(&gBackupState->opLock);
+   g_mutex_unlock(&gBackupState->opLock);
    return retVal;
 }
 
@@ -1007,7 +1007,7 @@ VmBackupStartCommon(RpcInData *data,
    gBackupState->provider = provider;
    gBackupState->completer = completer;
    gBackupState->needsPriv = FALSE;
-   g_static_mutex_init(&gBackupState->opLock);
+   g_mutex_init(&gBackupState->opLock);
    gBackupState->enableNullDriver = VMBACKUP_CONFIG_GET_BOOL(ctx->config,
                                                              "enableNullDriver",
                                                              TRUE);
--- a/open-vm-tools/services/plugins/vmbackup/vmBackupInt.h
+++ b/open-vm-tools/services/plugins/vmbackup/vmBackupInt.h
@@ -111,7 +111,7 @@ typedef struct VmBackupState {
    ToolsAppCtx   *ctx;
    VmBackupOp    *currentOp;
    const char    *currentOpName;
-   GStaticMutex   opLock; // See note above
+   GMutex         opLock;          // See note above
    char          *volumes;
    char          *snapshots;
    guint          pollPeriod;
@@ -207,14 +207,14 @@ VmBackup_SetCurrentOp(VmBackupState *sta
    ASSERT(state->currentOp == NULL);
    ASSERT(currentOpName != NULL);
 
-   g_static_mutex_lock(&state->opLock);
+   g_mutex_lock(&state->opLock);
 
    state->currentOp = op;
    state->callback = callback;
    state->currentOpName = currentOpName;
    state->forceRequeue = (callback != NULL && op == NULL);
 
-   g_static_mutex_unlock(&state->opLock);
+   g_mutex_unlock(&state->opLock);
 
    return (op != NULL);
 }
--- a/open-vm-tools/services/vmtoolsd/cmdLine.c
+++ b/open-vm-tools/services/vmtoolsd/cmdLine.c
@@ -304,9 +304,7 @@ ToolsCore_ParseCommandLine(ToolsServiceS
    }
 
    context = g_option_context_new(NULL);
-#if GLIB_CHECK_VERSION(2, 12, 0)
    g_option_context_set_summary(context, N_("Runs the VMware Tools daemon."));
-#endif
    g_option_context_add_main_entries(context, clOptions, NULL);
    g_option_group_set_error_hook(g_option_context_get_main_group(context),
                                  ToolsCoreCmdLineError);
--- a/open-vm-tools/services/vmtoolsd/mainLoop.c
+++ b/open-vm-tools/services/vmtoolsd/mainLoop.c
@@ -550,10 +550,6 @@ ToolsCore_Setup(ToolsServiceState *state
    GMainContext *gctx;
    ToolsServiceProperty ctxProp = { TOOLS_CORE_PROP_CTX };
 
-   if (!g_thread_supported()) {
-      g_thread_init(NULL);
-   }
-
    /*
     * Useful for debugging purposes. Log the vesion and build information.
     */
--- a/open-vm-tools/services/vmtoolsd/serviceObj.c
+++ b/open-vm-tools/services/vmtoolsd/serviceObj.c
@@ -180,14 +180,14 @@ ToolsCoreServiceGetProperty(GObject *obj
 
    id -= 1;
 
-   g_mutex_lock(self->lock);
+   g_mutex_lock(&self->lock);
 
    if (id < self->props->len) {
       ServiceProperty *p = &g_array_index(self->props, ServiceProperty, id);
       g_value_set_pointer(value, p->value);
    }
 
-   g_mutex_unlock(self->lock);
+   g_mutex_unlock(&self->lock);
 }
 
 
@@ -217,14 +217,14 @@ ToolsCoreServiceSetProperty(GObject *obj
 
    id -= 1;
 
-   g_mutex_lock(self->lock);
+   g_mutex_lock(&self->lock);
 
    if (id < self->props->len) {
       p = &g_array_index(self->props, ServiceProperty, id);
       p->value = g_value_get_pointer(value);
    }
 
-   g_mutex_unlock(self->lock);
+   g_mutex_unlock(&self->lock);
 
    if (p != NULL) {
       g_object_notify(object, p->name);
@@ -260,7 +260,7 @@ ToolsCoreServiceCtor(GType type,
                                                                       params);
 
    self = TOOLSCORE_SERVICE(object);
-   self->lock = g_mutex_new();
+   g_mutex_init(&self->lock);
    self->props = g_array_new(FALSE, FALSE, sizeof (ServiceProperty));
 
    return object;
@@ -296,7 +296,7 @@ ToolsCoreServiceDtor(GObject *object)
    }
 
    g_array_free(self->props, TRUE);
-   g_mutex_free(self->lock);
+   g_mutex_clear(&self->lock);
 }
 
 
@@ -459,7 +459,7 @@ ToolsCoreService_RegisterProperty(ToolsC
                                             prop->name,
                                             G_PARAM_READWRITE);
 
-   g_mutex_lock(obj->lock);
+   g_mutex_lock(&obj->lock);
 
    sprop.id = ++PROP_ID_SEQ;
    sprop.name = g_strdup(prop->name);
@@ -467,6 +467,6 @@ ToolsCoreService_RegisterProperty(ToolsC
    g_array_append_val(obj->props, sprop);
    g_object_class_install_property(G_OBJECT_CLASS(klass), sprop.id, pspec);
 
-   g_mutex_unlock(obj->lock);
+   g_mutex_unlock(&obj->lock);
 }
 
--- a/open-vm-tools/services/vmtoolsd/serviceObj.h
+++ b/open-vm-tools/services/vmtoolsd/serviceObj.h
@@ -1,5 +1,5 @@
 /*********************************************************
- * Copyright (C) 2009-2016 VMware, Inc. All rights reserved.
+ * Copyright (C) 2009-2018 VMware, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as published
@@ -39,7 +39,7 @@
 
 typedef struct ToolsCoreService {
    GObject        parent;
-   GMutex        *lock;
+   GMutex         lock;
    GArray        *props;
 } ToolsCoreService;
 
--- a/open-vm-tools/services/vmtoolsd/threadPool.c
+++ b/open-vm-tools/services/vmtoolsd/threadPool.c
@@ -1,5 +1,5 @@
 /*********************************************************
- * Copyright (C) 2010-2016 VMware, Inc. All rights reserved.
+ * Copyright (C) 2010-2018 VMware, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as published
@@ -40,7 +40,7 @@ typedef struct ThreadPoolState {
    GThreadPool   *pool;
    GQueue        *workQueue;
    GPtrArray     *threads;
-   GMutex        *lock;
+   GMutex         lock;
    guint          nextWorkId;
 } ThreadPoolState;
 
@@ -170,9 +170,9 @@ ToolsCorePoolDoWork(gpointer data)
     * In multi-threaded mode, the thread pool callback already did this.
     */
    if (gState.pool == NULL) {
-      g_mutex_lock(gState.lock);
+      g_mutex_lock(&gState.lock);
       g_queue_remove(gState.workQueue, work);
-      g_mutex_unlock(gState.lock);
+      g_mutex_unlock(&gState.lock);
    }
 
    work->cb(gState.ctx, work->data);
@@ -223,7 +223,7 @@ ToolsCorePoolRunThread(gpointer data)
    task->cb(gState.ctx, task->data);
    task->active = FALSE;
 
-   g_mutex_lock(gState.lock);
+   g_mutex_lock(&gState.lock);
    /* If not active, the shutdown function will clean things up. */
    if (gState.active) {
       g_ptr_array_remove(gState.threads, task);
@@ -232,7 +232,7 @@ ToolsCorePoolRunThread(gpointer data)
                       task,
                       ToolsCorePoolDestroyThread);
    }
-   g_mutex_unlock(gState.lock);
+   g_mutex_unlock(&gState.lock);
 
    return NULL;
 }
@@ -257,9 +257,9 @@ ToolsCorePoolRunWorker(gpointer state,
 {
    WorkerTask *work;
 
-   g_mutex_lock(gState.lock);
+   g_mutex_lock(&gState.lock);
    work = g_queue_pop_tail(gState.workQueue);
-   g_mutex_unlock(gState.lock);
+   g_mutex_unlock(&gState.lock);
 
    ASSERT(work != NULL);
 
@@ -300,7 +300,7 @@ ToolsCorePoolSubmit(ToolsAppCtx *ctx,
    task->data = data;
    task->dtor = dtor;
 
-   g_mutex_lock(gState.lock);
+   g_mutex_lock(&gState.lock);
 
    if (!gState.active) {
       g_free(task);
@@ -351,7 +351,7 @@ ToolsCorePoolSubmit(ToolsAppCtx *ctx,
                                  ToolsCorePoolDestroyTask);
 
 exit:
-   g_mutex_unlock(gState.lock);
+   g_mutex_unlock(&gState.lock);
    return id;
 }
 
@@ -378,7 +378,7 @@ ToolsCorePoolCancel(guint id)
 
    g_return_if_fail(id != 0);
 
-   g_mutex_lock(gState.lock);
+   g_mutex_lock(&gState.lock);
    if (!gState.active) {
       goto exit;
    }
@@ -390,7 +390,7 @@ ToolsCorePoolCancel(guint id)
    }
 
 exit:
-   g_mutex_unlock(gState.lock);
+   g_mutex_unlock(&gState.lock);
 
    if (task != NULL) {
       if (task->srcId > 0) {
@@ -410,11 +410,12 @@ exit:
  *
  * @see ToolsCorePool_StartThread()
  *
- * @param[in] ctx       Application context.
- * @param[in] cb        Callback that executes the task.
- * @param[in] interrupt Callback that interrupts the task.
- * @param[in] data      Opaque data.
- * @param[in] dtor      Destructor for the task data.
+ * @param[in] ctx        Application context.
+ * @param[in] threadName Name for the new thread.
+ * @param[in] cb         Callback that executes the task.
+ * @param[in] interrupt  Callback that interrupts the task.
+ * @param[in] data       Opaque data.
+ * @param[in] dtor       Destructor for the task data.
  *
  * @return TRUE iff thread was successfully started.
  *
@@ -423,6 +424,7 @@ exit:
 
 static gboolean
 ToolsCorePoolStart(ToolsAppCtx *ctx,
+                   const gchar *threadName,
                    ToolsCorePoolCb cb,
                    ToolsCorePoolCb interrupt,
                    gpointer data,
@@ -431,7 +433,7 @@ ToolsCorePoolStart(ToolsAppCtx *ctx,
    GError *err = NULL;
    StandaloneTask *task = NULL;
 
-   g_mutex_lock(gState.lock);
+   g_mutex_lock(&gState.lock);
    if (!gState.active) {
       goto exit;
    }
@@ -442,7 +444,7 @@ ToolsCorePoolStart(ToolsAppCtx *ctx,
    task->interrupt = interrupt;
    task->data = data;
    task->dtor = dtor;
-   task->thread = g_thread_create(ToolsCorePoolRunThread, task, TRUE, &err);
+   task->thread = g_thread_try_new(threadName, ToolsCorePoolRunThread, task, &err);
 
    if (err == NULL) {
       g_ptr_array_add(gState.threads, task);
@@ -454,7 +456,7 @@ ToolsCorePoolStart(ToolsAppCtx *ctx,
    }
 
 exit:
-   g_mutex_unlock(gState.lock);
+   g_mutex_unlock(&gState.lock);
    return task != NULL;
 }
 
@@ -497,7 +499,6 @@ ToolsCorePool_Init(ToolsAppCtx *ctx)
       gState.pool = g_thread_pool_new(ToolsCorePoolRunWorker,
                                       NULL, maxThreads, FALSE, &err);
       if (err == NULL) {
-#if GLIB_CHECK_VERSION(2, 10, 0)
          gint maxIdleTime;
          gint maxUnused;
 
@@ -517,7 +518,6 @@ ToolsCorePool_Init(ToolsAppCtx *ctx)
 
          g_thread_pool_set_max_idle_time(maxIdleTime);
          g_thread_pool_set_max_unused_threads(maxUnused);
-#endif
       } else {
          g_warning("error initializing thread pool, running single threaded: %s",
                    err->message);
@@ -526,7 +526,7 @@ ToolsCorePool_Init(ToolsAppCtx *ctx)
    }
 
    gState.active = TRUE;
-   gState.lock = g_mutex_new();
+   g_mutex_init(&gState.lock);
    gState.threads = g_ptr_array_new();
    gState.workQueue = g_queue_new();
 
@@ -553,9 +553,9 @@ ToolsCorePool_Shutdown(ToolsAppCtx *ctx)
 {
    guint i;
 
-   g_mutex_lock(gState.lock);
+   g_mutex_lock(&gState.lock);
    gState.active = FALSE;
-   g_mutex_unlock(gState.lock);
+   g_mutex_unlock(&gState.lock);
 
    /* Notify all spawned threads to stop. */
    for (i = 0; i < gState.threads->len; i++) {
@@ -589,7 +589,7 @@ ToolsCorePool_Shutdown(ToolsAppCtx *ctx)
    /* Cleanup. */
    g_ptr_array_free(gState.threads, TRUE);
    g_queue_free(gState.workQueue);
-   g_mutex_free(gState.lock);
+   g_mutex_clear(&gState.lock);
    memset(&gState, 0, sizeof gState);
    g_object_set(ctx->serviceObj, TOOLS_CORE_PROP_TPOOL, NULL, NULL);
 }
--- a/open-vm-tools/vgauth/service/fileLogger.c
+++ b/open-vm-tools/vgauth/service/fileLogger.c
@@ -74,11 +74,7 @@ ServiceFileLoggerOpen(FileLoggerData *da
 
    if (g_file_test(path, G_FILE_TEST_EXISTS)) {
       /* GStatBuf was added in 2.26. */
-#if GLIB_CHECK_VERSION(2, 26, 0)
       GStatBuf fstats;
-#else
-      struct stat fstats;
-#endif
 
       if (g_stat(path, &fstats) > -1) {
          g_atomic_int_set(&data->logSize, (gint) fstats.st_size);
